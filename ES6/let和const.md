let和const

# let和const

- [let和const]()
    - [1.let命令]()
    - [2.块级作用域]()
    - [3.const命令]()
    - [4.const本质]()
    - [5.顶层对象的属性]()
    - [6.globalThis对象]()

* * *

#### 1.let命令

* * *

- let只在它所在的作用于内有效
- let没有变量提升
- for循环使用let声明i时，每一轮循环时都是一个新的i
- 暂时性死区让typeof变得不是百分百安全
- 在同一作用域内不允许重复声明，有形参的函数内部也不行

#### 2.块级作用域

* * *

- 块级作用域用大括号表示
- 声明，包括函数声明都只能在作用域的顶层完成

#### 3.const命令

* * *

- const声明一个只读的常量，一经声明，常量的值不能改变
- const声明时必须同步赋值，否则报错
- const只在声明所在的作用域内有效

#### 4.const本质

* * *

- **const**实际上保证的，并不是变量的值不得改动，而是**变量指向的那个内存地址**所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个**指向实际数据的指针**，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。
- 如果真的想将对象冻结，应该使用**Object.freeze**方法。
- **Object.freeze()** 方法可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改。freeze() 返回和传入的参数相同的对象。

#### 5.顶层对象的属性

* * *

- 浏览器环境下的顶层对象是**windows**。在JS中，顶层对象windows的属性等同于全局变量。这是JS设计的最大缺陷之一。ES6为了改变这一缺陷，并没有将**let命令、const命令、class命令**声明的全局变量归属于顶层对象的属性。

#### 6.globalThis对象

* * *

- 鉴于对node还停留在懵懂阶段，暂时不收录
